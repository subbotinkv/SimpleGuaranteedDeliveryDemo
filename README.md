# SimpleGuaranteedDeliveryExample

## Описание задачи

Необходимо реализовать два приложения - клиент и сервер, обменивающиеся сообщениями.

### Клиент

Клиентское приложение должно получать от пользователя текстовые сообщения и отправлять их на сервер. Если сообщение не удалось доставить сразу же, то попытки доставки должны быть продолжены. Клиент должен продолжать попытки отправки недоставленных сообщений даже после перезапуска программы.

### Сервер

Сервер должен принимать сообщения, сохранять их и предоставлять пользователю возможность просмотреть все принятые сообщения. Кроме самого текста сообщения, сервер так же должен сохранять IP-адрес клиента и проставлять метку времени.

## Описание решения

- В демонстрационных целях, клиент и сервер реализованны в виде консольных приложений
- Для реализации серверной части использовано решение с применением SelfHosted сервиса ASP.NET Web API 2
- Для решения задачи надежного обмена сообщениями был использован паттерн [Guaranteed Delivery](http://www.enterpriseintegrationpatterns.com/patterns/messaging/GuaranteedMessaging.html)
- Конкретная реализация использует концепции [Message Store и Message Processor](https://docs.wso2.com/display/EI611/Working+with+Message+Stores+and+Message+Processors) для реализации гарантированной доставки
- В демонстрационных целях, в качестве хранилища используется файловая система

## TODO

- Выделить абстракцию MessageStore (MS) и предоставить различные реализации - FileSystemMS, JdbcMS, JmsMS, etc. Для целей тестирования можно предоставить InMemoryMessageStore. Для абстрагирования от конкретного способа хранения данных можно воспользоваться паттерном [Repository](http://design-pattern.ru/patterns/repository.html)
- Выделить абстракцию MessageProcessingStrategy (MPS) и предоставить различные реализация - RestMPS, SoapMPS, EmailMPS, etc. Для целей тестирования можно предоставить реализацию DoNothingMPS. Для абстрагирования от конкретного способа обработки сообщения можно воспользоваться паттерном [Strategy](https://refactoring.guru/ru/design-patterns/strategy)
- Выделить абстракцию Message Processor и внедрить в неё зависимости MS и MPS. Это позволит гибко настраивать тип хранилища и способ обработки сообщений
- Реализовать [Resiliency patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency) Retry и Circuit Breaker. Для реализации можно воспользоваться библиотекой [Polly](https://github.com/App-vNext/Polly)
- Добавить тесты
- Добавить логгирование фоновых процессов для диагностики работы приложения. Сама консоль используется для предоставления интерфейса пользователю, поэтому необходимо логгировать в другие хранилища в роли которых могут выступать, например, файлы или база данных. Для реализации логгирования можно воспользоваться соответствующими фреймворками -  [log4net](https://logging.apache.org/log4net/), [NLog](http://nlog-project.org/), etc.
- Для унификации процесса разработки и поставки можно использовать Docker (с учётом текущей версии фреймворка возможно использование только Windows Containers)
- Для абстрагирования от платформы можно перейти на .NET Core

## Альтернативные решения

- Замена ASP.NET Web API на Nancy FX (всё ещё подход с использование сервисов)
- Переход на использование очередей сообщений
- Использование специализированного фреймворка для реализации обмена сообщений, например, [NServiceBus](https://particular.net/nservicebus) или [MassTransit](http://masstransit-project.com/). Данные фреймворки соддержат необходимые механизмы для интеграции приложений на основе обмена сообщениями, а так же наборы абстракций позволяющие использовать различные виды транспорта, хранилищ, стратегий доставки сообщений.